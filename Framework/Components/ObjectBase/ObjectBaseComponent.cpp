#include "Framework.h"
#include "ObjectBaseComponent.h"

ObjectBaseComponent::ObjectBaseComponent()
	:shader(NULL), parent(NULL)
{
	baseTransform = new Transform();
}

ObjectBaseComponent::~ObjectBaseComponent()
{
	SafeDelete(baseTransform);
	
	if (NULL == parent)
	{
		// Root 컴포넌트일때. Root가 삭제되면서 전부 삭제될때.
		for (ObjectBaseComponent* child : children)
		{
			//순차적으로 링크 끊고 해제하기
			child->UnlinkParentComponent();
			SafeDelete(child);
		}
	}
	else
	{
		// 삭제시 상위 컴포넌트에 차일드 넘기기
		for (ObjectBaseComponent* child : children)
			parent->LinkChildComponent(child);
	}
	children.clear();
	children.shrink_to_fit();
	SafeDelete(shader);
}

void ObjectBaseComponent::Update()
{
	if (NULL == parent)
	{

	}
	// 모델 메시 아니면 소켓이 필요 없음.
	// 매번 위치 바꿔줄 필요도 없음.

	else if (parent->GetType() == ObjectBaseComponentType::ModelMesh)
	{
		//부모를 다이나믹 형변환해서 컴포넌트 추출
		ModelMeshComponent* modelMesh = dynamic_cast<ModelMeshComponent*>(parent);
		// 모델과 애니메이터 추출
		ModelAnimator* animator = modelMesh->GetAnimation();
		//같은 오브젝트면 소켓도 같음
		
		if (NULL!= animator && parentSocket >= 0)
		{
			// 인스턴스만큼 위치 업뎃.
			UINT instCount = modelMesh->GetInstSize();
			for (UINT i = 0; i < instCount; i++)
			{
				Matrix world = modelMesh->GetTransform(i)->World();
				Matrix attach = animator->GetboneWorld(i, parentSocket);
				attach *= world;

				this->GetTransform(i)->Parent(attach);
			}
		}
	}
	//루트만 업데이트 호출하면 자식 자동 호출하게
	for (ObjectBaseComponent* child : children)
		child->Update();
}

void ObjectBaseComponent::Render()
{
	for (ObjectBaseComponent* child : children)
		child->Render();
}

bool ObjectBaseComponent::Property()
{
	bool bChange = false;

	ImGui::Text("ParentBone : %s", String::ToString( parentSocketName).c_str());

	if (NULL == parent)
	{

	}
	else if (parent->GetType() == ObjectBaseComponentType::ModelMesh)
	{
		ModelMeshComponent* modelMesh = dynamic_cast<ModelMeshComponent*>(parent);
		Model* model = modelMesh->GetMesh();

		
		int click = -1;
		int presocket = parentSocket;
		if (ImGui::CollapsingHeader("SelectBone"))
		{
			parentSocket = model->BoneHierarchy(&click);
		}
			
		bChange |= presocket != parentSocket;
		if (true == bChange)
		{
			if (parentSocket < 0)
				parentSocketName = L"None";
			else
				parentSocketName = model->BoneByIndex(parentSocket)->Name();
		}
	}
	return bChange;
}

void ObjectBaseComponent::Tech(const UINT & mesh, const UINT & model, const UINT & anim)
{
	for (ObjectBaseComponent* child : children)
		child->Tech(mesh,model,anim);
}

void ObjectBaseComponent::Pass(const UINT & mesh, const UINT & model, const UINT & anim)
{
	for (ObjectBaseComponent* child : children)
		child->Pass(mesh, model, anim);
}

void ObjectBaseComponent::SetShader(Shader * shader)
{
	this->shader = shader;
	//for (ObjectBaseComponent* child : children)
	//	child->SetShader(shader);
}

void ObjectBaseComponent::AddInstanceData()
{
	instancingCount++;
	for (ObjectBaseComponent* child : children)
		child->AddInstanceData();
}

void ObjectBaseComponent::DelInstanceData(const UINT & instance)
{
	if(instancingCount>0)
		instancingCount--;

	for (ObjectBaseComponent* child : children)
		child->DelInstanceData(instance);
}

void ObjectBaseComponent::ComponentHeirarchy(OUT ObjectBaseComponent** selectedComp)
{
	//아이템 시작지점
	ImVec2 pos = ImGui::GetItemRectMin() - ImGui::GetWindowPos();
	//윈도우 사이즈
	ImVec2 wSize = ImGui::GetWindowSize();
	if (wSize.y < pos.y) return;
	if (wSize.x < pos.x) return;

	ImGuiTreeNodeFlags flags = children.empty() ? ImGuiTreeNodeFlags_Leaf : ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_OpenOnDoubleClick;

	if (this == *selectedComp)
		flags |= ImGuiTreeNodeFlags_Selected;
	ImGui::PushStyleVar(ImGuiStyleVar_IndentSpacing, 10.0f);

	if (ImGui::TreeNodeEx(String::ToString(componentName).c_str(), flags))
	{
		if (ImGui::IsItemClicked())
		{
			*selectedComp = this;
		}
		if (ImGui::IsItemClicked(1))
		{
			*selectedComp = this;
			ImGui::OpenPopup("AddComponentPopup");
		}
		ComponentPopup();
		for (auto& child : children)
		{
			child->ComponentHeirarchy(selectedComp);
		}
		ImGui::TreePop();
	}
	ImGui::PopStyleVar();
}

void ObjectBaseComponent::ComponentPopup()
{
	bool boo = false;
	int itemIdx = -1;
	if (ImGui::BeginPopup("AddComponentPopup"))
	{
		if (ImGui::BeginMenu("SkeletonMeshComponent"))
		{
			AddSkeletonMeshComponentPopup();
			ImGui::EndMenu();
		}
		if (ImGui::BeginMenu("FigureMeshComponent"))
		{
			AddFigureMeshComponentPopup();
			ImGui::EndMenu();
		}
		if (ImGui::BeginMenu("CollisionComponent"))
		{
			ImGui::EndMenu();
		}
		if (ImGui::BeginMenu("CameraComponent"))
		{
			ImGui::EndMenu();
		}
		ImGui::EndPopup();
	}
}

void ObjectBaseComponent::AddSkeletonMeshComponentPopup()
{
	//TODO : 에셋 매니져에 등록된 SkeletonMesh에서 컴포넌트 생성해서 받기
	ModelAsset* asset =dynamic_cast<ModelAsset*>( AssetManager::Get()->ViewAssets(ContentsAssetType::Model));

	if (NULL != asset)
	{
		LinkChildComponent(asset->GetModelMeshCompFromModelAsset());
	}
}

void ObjectBaseComponent::AddFigureMeshComponentPopup()
{
	//TODO : 에셋 매니져에 등록된 FigureMesh에서 컴포넌트 생성해서 받기
}

void ObjectBaseComponent::AddCollisionComponentPopup()
{
	//TODO : CollisionType 선택하기.
}


#pragma region 부모자식 링크/언링크
void ObjectBaseComponent::LinkParentComponent(ObjectBaseComponent * component)
{
	parent = component;

	//컴포넌트의 인스턴싱 갯수 맞추는건 여기서 할거임.
	UINT parentInst = component->GetInstSize();
	UINT maxLoop = parentInst > instancingCount ? parentInst : instancingCount;
	for (UINT i = 0; i < maxLoop; i++)
	{
		//부모 컴포넌트의 인스턴싱 갯수가 더 적음
		if (parentInst - 1 < i)
		{
			component->AddInstanceData();
		}
		//자식 컴포넌트의 인스턴싱 갯수가 더 적음
		else if (instancingCount < i + 1)
		{
			AddInstanceData();
		}

		//위치 조정
		GetTransform(i)->Parent(component->GetTransform(i));
	}
	
}

void ObjectBaseComponent::UnlinkParentComponent()
{
	parent = NULL;

	// 이미 Link할때 갯수 맞췄으니 인스턴싱 데이터 맞춰서 삭제만 해주면 될것.
	for (UINT i = 0; i < instancingCount; i++)
	{
		GetTransform(i)->Parent(NULL);
	}
}

void ObjectBaseComponent::LinkChildComponent(ObjectBaseComponent * component)
{
	children.emplace_back(component);
	//자식의 쉐이더도 자신의 쉐이더와 통일
	component->SetShader(shader);
	component->LinkParentComponent(this);
}

void ObjectBaseComponent::UnlinkChildComponent(ObjectBaseComponent * component)
{
	int index = 0;

	for (ObjectBaseComponent* child : children)
	{
		if (child == component)
		{
			child->UnlinkParentComponent();
			children.erase(children.begin() + index);
			break;
		}
		index++;
	}
}
#pragma endregion
