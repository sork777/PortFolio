#include "Framework.h"
#include "ObjectBaseComponent.h"

ObjectBaseComponent::ObjectBaseComponent()
	:shader(NULL), parent(NULL)
{
	baseTransform = new Transform();
}

ObjectBaseComponent::~ObjectBaseComponent()
{
	SafeDelete(baseTransform);
	
	if (NULL == parent)
	{
		// Root 컴포넌트일때. Root가 삭제되면서 전부 삭제될때.
		for (ObjectBaseComponent* child : children)
		{
			//순차적으로 링크 끊고 해제하기
			child->UnlinkParentComponent();
			SafeDelete(child);
		}
	}
	else
	{
		// 삭제시 상위 컴포넌트에 차일드 넘기기
		for (ObjectBaseComponent* child : children)
			parent->LinkChildComponent(child);
	}
	children.clear();
	children.shrink_to_fit();
	SafeDelete(shader);
}

void ObjectBaseComponent::Update()
{
	if (NULL == parent)
	{

	}
	// 모델 메시 아니면 소켓이 필요 없음.
	// 매번 위치 바꿔줄 필요도 없음.

	else if (parent->GetType() == ObjectBaseComponentType::ModelMesh)
	{
		//부모를 다이나믹 형변환해서 컴포넌트 추출
		ModelMeshComponent* modelMesh = dynamic_cast<ModelMeshComponent*>(parent);
		// 모델과 애니메이터 추출
		ModelAnimator* animator = modelMesh->GetAnimation();
		//같은 오브젝트면 소켓도 같음
		
		if (NULL!= animator && parentSocket >= 0)
		{
			// 인스턴스만큼 위치 업뎃.
			// 에딧중이면 첫번째 인스턴스만.
			UINT instCount = bEditMode? 1: modelMesh->GetInstSize();
			for (UINT i = 0; i < instCount; i++)
			{
				Matrix world = modelMesh->GetTransform(i)->World();
				Matrix attach = animator->GetboneWorld(i, parentSocket);
				attach *= world;

				this->GetTransform(i)->Parent(attach);
			}
		}
	}

	//루트만 업데이트 호출하면 자식 자동 호출하게
	for (ObjectBaseComponent* child : children)
	{
		// 에딧모드 아닌데 컴파일도 안되어있으면 배제
		if (false == child->bEditMode && false == child->bCompiled) continue;
		// 에딧모드인데 활성화 안되어있으면 배제
		if (true  == child->bEditMode && false == child->bActive) continue;
		
		child->Update();
	}
}

void ObjectBaseComponent::Render()
{
	for (ObjectBaseComponent* child : children)
	{
		if (false == child->bEditMode && false == child->bCompiled) continue;
		if (true  == child->bEditMode && false == child->bActive) continue;

		child->Render();
	}
}

bool ObjectBaseComponent::Property(const UINT& instance)
{
	bool bChange = false;

	ImGui::Text("ParentBone : %s", String::ToString( parentSocketName).c_str());

	if (NULL == parent)
	{

	}
	else if (parent->GetType() == ObjectBaseComponentType::ModelMesh)
	{
		ModelMeshComponent* modelMesh = dynamic_cast<ModelMeshComponent*>(parent);
		Model* model = modelMesh->GetMesh();

		
		int click = -1;
		int presocket = parentSocket;
		if (ImGui::CollapsingHeader("SelectBone"))
		{
			parentSocket = model->BoneHierarchy(&click);
		}
			
		bChange |= presocket != parentSocket;
		if (true == bChange)
		{
			if (parentSocket < 0)
				parentSocketName = L"None";
			else
				parentSocketName = model->BoneByIndex(parentSocket)->Name();
		}
	}
	return bChange;
}

#pragma region Shader 관련

void ObjectBaseComponent::SetShader(Shader * shader)
{
	this->shader = shader;
}

void ObjectBaseComponent::Tech(const UINT & mesh, const UINT & model, const UINT & anim)
{
	for (ObjectBaseComponent* child : children)
		child->Tech(mesh,model,anim);
}

void ObjectBaseComponent::Pass(const UINT & mesh, const UINT & model, const UINT & anim)
{
	for (ObjectBaseComponent* child : children)
		child->Pass(mesh, model, anim);
}

#pragma endregion

void ObjectBaseComponent::AddInstanceData()
{
	int index = chageTrans.size();
	chageTrans.emplace_back(false);
	if (NULL != parent)
		GetTransform(index)->Parent(parent->GetTransform(index));
	for (ObjectBaseComponent* child : children)
		child->AddInstanceData();
}

void ObjectBaseComponent::DelInstanceData(const UINT & instance)
{
	if (instance >= chageTrans.size())
		return;
	chageTrans.erase(chageTrans.begin() + instance);
	for (ObjectBaseComponent* child : children)
		child->DelInstanceData(instance);
}

void ObjectBaseComponent::CompileComponent()
{
	//루트가 이동하면 안됨.
	if (NULL != parent)
	{
		UINT instCount = GetInstSize();
		for (UINT i = 0; i < instCount; i++)
		{
			//인스턴스마다 변경된 기본값으로 다시 이동
			//개별 변동인 인스턴스는 냅둠
			if(chageTrans[i] == false)
				GetTransform(i)->Local(baseTransform);
		}
	}
	// 컴파일 표시를 하여 업데이트 및 랜더되게 함.
	bCompiled = true;
	for (ObjectBaseComponent* child : children)
	{
		// 자식컴포넌트가 비활성화 상태면 언링크
		// 아니면 컴파일
		if (false == child->bActive)
			UnlinkChildComponent(child);
		else
			child->CompileComponent();
	}
}

void ObjectBaseComponent::ReadyToUnlinkComp()
{
	// 컴포넌트 비활성화
	// 목록에서 제거 및 업데이트/랜더 배제	
	// 에디터에서나 표현할것.
	bActive = false;
	for (ObjectBaseComponent* child : children)
		child->bActive = false;
}

#pragma region Component 계층/팝업

void ObjectBaseComponent::ComponentHeirarchy(OUT ObjectBaseComponent** selectedComp)
{
	// 비활성화된 컴포넌트 배제
	if(false == bActive) return;



	//아이템 시작지점
	ImVec2 pos = ImGui::GetItemRectMin() - ImGui::GetWindowPos();
	//윈도우 사이즈
	ImVec2 wSize = ImGui::GetWindowSize();
	if (wSize.y < pos.y) return;
	if (wSize.x < pos.x) return;

	ImGuiTreeNodeFlags flags = children.empty() ? ImGuiTreeNodeFlags_Leaf : ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_OpenOnDoubleClick;

	if (this == *selectedComp)
		flags |= ImGuiTreeNodeFlags_Selected;
	ImGui::PushStyleVar(ImGuiStyleVar_IndentSpacing, 10.0f);

	if (ImGui::TreeNodeEx(String::ToString(componentName).c_str(), flags))
	{
		if (ImGui::IsItemClicked())
		{
			*selectedComp = this;
		}
		if (ImGui::IsItemClicked(1))
		{
			*selectedComp = this;
			ImGui::OpenPopup("AddComponentPopup");
		}
		ComponentPopup();
		for (auto& child : children)
		{
			child->ComponentHeirarchy(selectedComp);
		}
		ImGui::TreePop();
	}
	ImGui::PopStyleVar();
}

void ObjectBaseComponent::ComponentPopup()
{
	bool boo = false;
	int itemIdx = -1;
	if (ImGui::BeginPopup("AddComponentPopup"))
	{
		if (ImGui::BeginMenu("SkeletonMeshComponent"))
		{
			AddSkeletonMeshComponentPopup();
			ImGui::EndMenu();
		}
		if (ImGui::BeginMenu("FigureMeshComponent"))
		{
			AddFigureMeshComponentPopup();
			ImGui::EndMenu();
		}
		if (ImGui::BeginMenu("CollisionComponent"))
		{
			AddCollisionComponentPopup();
			ImGui::EndMenu();
		}
		if (ImGui::BeginMenu("CameraComponent"))
		{
			ImGui::EndMenu();
		}
		ImGui::EndPopup();
	}
}

void ObjectBaseComponent::AddSkeletonMeshComponentPopup()
{
	//TODO : 에셋 매니져에 등록된 SkeletonMesh에서 컴포넌트 생성해서 받기
	ModelAsset* asset =dynamic_cast<ModelAsset*>( AssetManager::Get()->ViewAssets(ContentsAssetType::Model));

	if (NULL != asset)
	{
		LinkChildComponent(asset->GetModelMeshCompFromModelAsset());
	}
}

void ObjectBaseComponent::AddFigureMeshComponentPopup()
{
	//TODO : 에셋 매니져에 등록된 FigureMesh에서 컴포넌트 생성해서 받기
}

void ObjectBaseComponent::AddCollisionComponentPopup()
{
	//TODO : 나중에 CollisionType 선택하기.
	if (ImGui::Button("OBB_Collision"))
	{
		OBB_CollisionComponent* addComp = new OBB_CollisionComponent();
	
		LinkChildComponent(addComp);	
	}
}

#pragma endregion

#pragma region 부모자식 링크/언링크
void ObjectBaseComponent::LinkParentComponent(ObjectBaseComponent * component)
{
	parent = component;

	//컴포넌트의 인스턴싱 갯수 맞추는건 여기서 할거임.
	UINT parentInst = component->GetInstSize();
	UINT instancingCount = GetInstSize();
	UINT maxLoop = parentInst > instancingCount ? parentInst : instancingCount;
	for (UINT i = 0; i < maxLoop; i++)
	{
		//부모 컴포넌트의 인스턴싱 갯수가 더 적음
		if (parentInst - 1 < i)
		{
			component->AddInstanceData();
		}
		//자식 컴포넌트의 인스턴싱 갯수가 더 적음
		else if (instancingCount < i + 1)
		{
			AddInstanceData();
		}

		//위치 조정
		GetTransform(i)->Parent(component->GetTransform(i));
	}
	
}

void ObjectBaseComponent::UnlinkParentComponent()
{
	parent = NULL;

	UINT instancingCount = GetInstSize();
	// 이미 Link할때 갯수 맞췄으니 인스턴싱 데이터 맞춰서 삭제만 해주면 될것.
	for (UINT i = 0; i < instancingCount; i++)
	{
		GetTransform(i)->Parent(NULL);
	}
}

void ObjectBaseComponent::LinkChildComponent(ObjectBaseComponent * component)
{
	children.emplace_back(component);
	//자식의 쉐이더도 자신의 쉐이더와 통일
	component->SetShader(shader);
	component->LinkParentComponent(this);
}

void ObjectBaseComponent::UnlinkChildComponent(ObjectBaseComponent * component)
{
	int index = 0;

	for (ObjectBaseComponent* child : children)
	{
		if (child == component)
		{
			child->UnlinkParentComponent();
			children.erase(children.begin() + index);
			break;
		}
		index++;
	}
}
#pragma endregion
